"""
Enhanced GitHub Client for Micro-Phase Workflows.
Provides advanced repository management, branch protection, CI/CD integration.
"""

import os
import json
import asyncio
import aiohttp
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
from dataclasses import dataclass, asdict
from enum import Enum


class BranchProtectionLevel(str, Enum):
    """Branch protection levels."""
    NONE = "none"
    BASIC = "basic"
    STRICT = "strict"
    ENTERPRISE = "enterprise"


class MergeMethod(str, Enum):
    """PR merge methods."""
    MERGE = "merge"
    SQUASH = "squash"
    REBASE = "rebase"


@dataclass
class RepositoryConfig:
    """Repository configuration for micro-phase workflow."""
    name: str
    description: str
    private: bool = True
    auto_init: bool = True
    default_branch: str = "main"
    development_branch: str = "develop"
    enable_issues: bool = True
    enable_projects: bool = True
    enable_wiki: bool = False
    gitignore_template: str = "Python"
    license_template: Optional[str] = None
    allow_merge_commit: bool = True
    allow_squash_merge: bool = True
    allow_rebase_merge: bool = False
    delete_branch_on_merge: bool = True


@dataclass
class BranchProtectionConfig:
    """Branch protection configuration."""
    level: BranchProtectionLevel = BranchProtectionLevel.BASIC
    required_status_checks: List[str] = None
    enforce_admins: bool = False
    required_pull_request_reviews: bool = True
    required_approving_review_count: int = 1
    dismiss_stale_reviews: bool = True
    require_code_owner_reviews: bool = False
    restrictions_users: List[str] = None
    restrictions_teams: List[str] = None
    
    def __post_init__(self):
        if self.required_status_checks is None:
            self.required_status_checks = []
        if self.restrictions_users is None:
            self.restrictions_users = []
        if self.restrictions_teams is None:
            self.restrictions_teams = []


@dataclass
class PullRequestTemplate:
    """Pull request template configuration."""
    title_template: str = "Micro-phase: {phase_name}"
    body_template: str = """## ðŸš€ Micro-Phase Implementation

### Summary
{phase_description}

### Changes Made
{changes_summary}

### Files Modified
{files_list}

### Testing
{testing_notes}

### Integration Notes
{integration_notes}

---
ðŸ¤– Generated by AI Orchestrator Micro-Phase Workflow
Session ID: {session_id}
Phase ID: {phase_id}
"""
    auto_assign_reviewers: bool = True
    auto_add_labels: bool = True
    default_labels: List[str] = None
    
    def __post_init__(self):
        if self.default_labels is None:
            self.default_labels = ["ai-generated", "micro-phase", "enhancement"]


class EnhancedGitHubClient:
    """
    Enhanced GitHub client for micro-phase workflows.
    
    Provides advanced repository management, branch protection,
    CI/CD integration, and automated PR workflows.
    """
    
    def __init__(self, token: Optional[str] = None, org: Optional[str] = None):
        """Initialize enhanced GitHub client."""
        self.token = token or os.getenv('GITHUB_TOKEN')
        self.org = org or os.getenv('GITHUB_ORG')
        self.base_url = "https://api.github.com"
        
        if not self.token:
            raise ValueError("GitHub token required. Set GITHUB_TOKEN environment variable.")
        
        # Cache for repository information
        self._repo_cache: Dict[str, Dict[str, Any]] = {}
        self._user_cache: Optional[Dict[str, Any]] = None
    
    def _get_headers(self) -> Dict[str, str]:
        """Get GitHub API headers with enhanced authentication."""
        return {
            "Authorization": f"token {self.token}",
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json",
            "User-Agent": "AI-Orchestrator-Enhanced-Client/2.0"
        }
    
    async def _make_request(self, method: str, url: str, 
                           data: Optional[Dict] = None, 
                           params: Optional[Dict] = None) -> Dict[str, Any]:
        """Make async HTTP request to GitHub API with error handling."""
        headers = self._get_headers()
        
        async with aiohttp.ClientSession() as session:
            async with session.request(
                method=method,
                url=url,
                json=data,
                params=params,
                headers=headers
            ) as response:
                if response.status >= 400:
                    error_text = await response.text()
                    raise Exception(f"GitHub API error {response.status}: {error_text}")
                
                return await response.json()
    
    async def create_micro_phase_repository(self, config: RepositoryConfig) -> Dict[str, Any]:
        """Create repository optimized for micro-phase workflow."""
        url = f"{self.base_url}/user/repos" if not self.org else f"{self.base_url}/orgs/{self.org}/repos"
        
        repo_data = {
            "name": config.name,
            "description": config.description,
            "private": config.private,
            "auto_init": config.auto_init,
            "gitignore_template": config.gitignore_template,
            "license_template": config.license_template,
            "allow_merge_commit": config.allow_merge_commit,
            "allow_squash_merge": config.allow_squash_merge,
            "allow_rebase_merge": config.allow_rebase_merge,
            "delete_branch_on_merge": config.delete_branch_on_merge,
            "has_issues": config.enable_issues,
            "has_projects": config.enable_projects,
            "has_wiki": config.enable_wiki
        }
        
        # Remove None values
        repo_data = {k: v for k, v in repo_data.items() if v is not None}
        
        repository = await self._make_request("POST", url, data=repo_data)
        
        # Cache repository info
        self._repo_cache[config.name] = repository
        
        # Set up development branch if different from default
        if config.development_branch != config.default_branch:
            await self.create_branch(
                repo_name=config.name,
                branch_name=config.development_branch,
                base_branch=config.default_branch
            )
        
        return repository
    
    async def setup_branch_protection(self, repo_name: str, branch: str, 
                                     config: BranchProtectionConfig) -> Dict[str, Any]:
        """Set up branch protection rules."""
        owner = self.org or await self._get_authenticated_user_login()
        url = f"{self.base_url}/repos/{owner}/{repo_name}/branches/{branch}/protection"
        
        protection_data = {
            "required_status_checks": {
                "strict": True,
                "contexts": config.required_status_checks
            } if config.required_status_checks else None,
            "enforce_admins": config.enforce_admins,
            "required_pull_request_reviews": {
                "required_approving_review_count": config.required_approving_review_count,
                "dismiss_stale_reviews": config.dismiss_stale_reviews,
                "require_code_owner_reviews": config.require_code_owner_reviews
            } if config.required_pull_request_reviews else None,
            "restrictions": {
                "users": config.restrictions_users,
                "teams": config.restrictions_teams
            } if config.restrictions_users or config.restrictions_teams else None
        }
        
        # Remove None values
        protection_data = {k: v for k, v in protection_data.items() if v is not None}
        
        return await self._make_request("PUT", url, data=protection_data)
    
    async def create_branch(self, repo_name: str, branch_name: str, 
                           base_branch: str = "main") -> Dict[str, Any]:
        """Create a new branch from base branch."""
        owner = self.org or await self._get_authenticated_user_login()
        base_url = f"{self.base_url}/repos/{owner}/{repo_name}"
        
        # Get base branch reference
        ref_url = f"{base_url}/git/refs/heads/{base_branch}"
        ref_data = await self._make_request("GET", ref_url)
        base_sha = ref_data["object"]["sha"]
        
        # Create new branch
        branch_data = {
            "ref": f"refs/heads/{branch_name}",
            "sha": base_sha
        }
        
        return await self._make_request("POST", f"{base_url}/git/refs", data=branch_data)
    
    async def commit_micro_phase_files(self, repo_name: str, branch: str, 
                                      files: Dict[str, str], phase_info: Dict[str, Any]) -> Dict[str, Any]:
        """Commit micro-phase files with enhanced metadata."""
        owner = self.org or await self._get_authenticated_user_login()
        base_url = f"{self.base_url}/repos/{owner}/{repo_name}"
        
        # Get current branch reference
        ref_url = f"{base_url}/git/refs/heads/{branch}"
        ref_data = await self._make_request("GET", ref_url)
        current_sha = ref_data["object"]["sha"]
        
        # Create tree with all files
        tree_items = []
        for file_path, content in files.items():
            # Create blob for file content
            blob_data = {"content": content, "encoding": "utf-8"}
            blob_response = await self._make_request("POST", f"{base_url}/git/blobs", data=blob_data)
            blob_sha = blob_response["sha"]
            
            tree_items.append({
                "path": file_path,
                "mode": "100644",
                "type": "blob",
                "sha": blob_sha
            })
        
        # Create tree
        tree_data = {"tree": tree_items}
        tree_response = await self._make_request("POST", f"{base_url}/git/trees", data=tree_data)
        tree_sha = tree_response["sha"]
        
        # Create commit with enhanced metadata
        commit_message = f"ðŸš€ Implement micro-phase: {phase_info.get('name', 'Unknown')}"
        
        metadata = {
            "micro_phase_id": phase_info.get("id"),
            "phase_name": phase_info.get("name"),
            "phase_type": phase_info.get("phase_type"),
            "session_id": phase_info.get("session_id"),
            "files_count": len(files),
            "generated_at": datetime.utcnow().isoformat(),
            "ai_orchestrator_version": "2.0.0"
        }
        
        full_message = f"{commit_message}\n\nMicro-Phase Metadata:\n{json.dumps(metadata, indent=2)}"
        
        commit_data = {
            "message": full_message,
            "tree": tree_sha,
            "parents": [current_sha]
        }
        
        commit_response = await self._make_request("POST", f"{base_url}/git/commits", data=commit_data)
        commit_sha = commit_response["sha"]
        
        # Update branch reference
        update_data = {"sha": commit_sha}
        await self._make_request("PATCH", ref_url, data=update_data)
        
        return commit_response
    
    async def create_micro_phase_pull_request(self, repo_name: str, phase_info: Dict[str, Any], 
                                             head_branch: str, base_branch: str = "develop",
                                             template: Optional[PullRequestTemplate] = None) -> Dict[str, Any]:
        """Create pull request for micro-phase with template."""
        if template is None:
            template = PullRequestTemplate()
        
        owner = self.org or await self._get_authenticated_user_login()
        url = f"{self.base_url}/repos/{owner}/{repo_name}/pulls"
        
        # Format title
        title = template.title_template.format(
            phase_name=phase_info.get("name", "Unknown Phase")
        )
        
        # Format body
        body = template.body_template.format(
            phase_description=phase_info.get("description", "No description provided"),
            changes_summary=phase_info.get("changes_summary", "Micro-phase implementation"),
            files_list="\n".join([f"- {f}" for f in phase_info.get("files_modified", [])]),
            testing_notes=phase_info.get("testing_notes", "Automated validation completed"),
            integration_notes=phase_info.get("integration_notes", "Ready for integration"),
            session_id=phase_info.get("session_id", "N/A"),
            phase_id=phase_info.get("id", "N/A")
        )
        
        pr_data = {
            "title": title,
            "head": head_branch,
            "base": base_branch,
            "body": body,
            "draft": False
        }
        
        pull_request = await self._make_request("POST", url, data=pr_data)
        
        # Add labels if configured
        if template.auto_add_labels and template.default_labels:
            await self.add_pr_labels(repo_name, pull_request["number"], template.default_labels)
        
        return pull_request
    
    async def add_pr_labels(self, repo_name: str, pr_number: int, labels: List[str]) -> Dict[str, Any]:
        """Add labels to pull request."""
        owner = self.org or await self._get_authenticated_user_login()
        url = f"{self.base_url}/repos/{owner}/{repo_name}/issues/{pr_number}/labels"
        
        return await self._make_request("POST", url, data={"labels": labels})
    
    async def add_pr_comment(self, repo_name: str, pr_number: int, comment: str) -> Dict[str, Any]:
        """Add comment to pull request."""
        owner = self.org or await self._get_authenticated_user_login()
        url = f"{self.base_url}/repos/{owner}/{repo_name}/issues/{pr_number}/comments"
        
        data = {"body": comment}
        return await self._make_request("POST", url, data=data)
    
    async def setup_ci_cd_workflow(self, repo_name: str, workflow_config: Dict[str, Any]) -> Dict[str, Any]:
        """Set up GitHub Actions CI/CD workflow."""
        owner = self.org or await self._get_authenticated_user_login()
        
        workflow_content = self._generate_workflow_yaml(workflow_config)
        
        files = {
            ".github/workflows/ci.yml": workflow_content
        }
        
        return await self.commit_micro_phase_files(
            repo_name=repo_name,
            branch="main",
            files=files,
            phase_info={
                "name": "CI/CD Setup",
                "session_id": workflow_config.get("session_id", "setup"),
                "id": "ci_setup"
            }
        )
    
    def _generate_workflow_yaml(self, config: Dict[str, Any]) -> str:
        """Generate GitHub Actions workflow YAML."""
        return f"""name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    
    - name: Run tests
      run: |
        python -m pytest tests/ --verbose --cov=./ --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  lint:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.9'
    
    - name: Install linting tools
      run: |
        python -m pip install --upgrade pip
        pip install black flake8 mypy
    
    - name: Run black
      run: black --check .
    
    - name: Run flake8
      run: flake8 .
    
    - name: Run mypy
      run: mypy . --ignore-missing-imports

  security:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Run security scan
      uses: github/super-linter@v4
      env:
        DEFAULT_BRANCH: main
        GITHUB_TOKEN: ${{{{ secrets.GITHUB_TOKEN }}}}
"""
    
    async def merge_pull_request(self, repo_name: str, pr_number: int, 
                                merge_method: MergeMethod = MergeMethod.SQUASH) -> Dict[str, Any]:
        """Merge pull request with specified method."""
        owner = self.org or await self._get_authenticated_user_login()
        url = f"{self.base_url}/repos/{owner}/{repo_name}/pulls/{pr_number}/merge"
        
        data = {
            "merge_method": merge_method.value
        }
        
        return await self._make_request("PUT", url, data=data)
    
    async def get_repository_info(self, repo_name: str) -> Dict[str, Any]:
        """Get repository information with caching."""
        if repo_name in self._repo_cache:
            return self._repo_cache[repo_name]
        
        owner = self.org or await self._get_authenticated_user_login()
        url = f"{self.base_url}/repos/{owner}/{repo_name}"
        
        repo_info = await self._make_request("GET", url)
        self._repo_cache[repo_name] = repo_info
        
        return repo_info
    
    async def list_pull_requests(self, repo_name: str, state: str = "open") -> List[Dict[str, Any]]:
        """List pull requests for repository."""
        owner = self.org or await self._get_authenticated_user_login()
        url = f"{self.base_url}/repos/{owner}/{repo_name}/pulls"
        
        params = {"state": state}
        return await self._make_request("GET", url, params=params)
    
    async def get_pr_status(self, repo_name: str, pr_number: int) -> Dict[str, Any]:
        """Get pull request status including CI/CD checks."""
        owner = self.org or await self._get_authenticated_user_login()
        
        # Get PR info
        pr_url = f"{self.base_url}/repos/{owner}/{repo_name}/pulls/{pr_number}"
        pr_info = await self._make_request("GET", pr_url)
        
        # Get status checks
        status_url = f"{self.base_url}/repos/{owner}/{repo_name}/commits/{pr_info['head']['sha']}/status"
        status_info = await self._make_request("GET", status_url)
        
        return {
            "pull_request": pr_info,
            "status_checks": status_info,
            "mergeable": pr_info.get("mergeable", False),
            "mergeable_state": pr_info.get("mergeable_state", "unknown")
        }
    
    async def _get_authenticated_user_login(self) -> str:
        """Get authenticated user login with caching."""
        if self._user_cache is None:
            user_url = f"{self.base_url}/user"
            self._user_cache = await self._make_request("GET", user_url)
        
        return self._user_cache["login"]
    
    async def cleanup(self):
        """Cleanup resources."""
        self._repo_cache.clear()
        self._user_cache = None